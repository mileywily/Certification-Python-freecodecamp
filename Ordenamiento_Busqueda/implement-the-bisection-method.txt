** start of main.py **

def square_root_bisection(number, tolerance=1e-7, max_iterations=100):
    if number < 0:
        raise ValueError("Square root of negative number is not defined in real numbers")
    
    if number == 0 or number == 1:
        print(f"The square root of {number} is {number}")
        return number

    low = 0
    high = max(1, number)
    root = None

    for i in range(max_iterations):
        mid = (low + high) / 2
        square_mid = mid**2

        # Actualizamos root en cada paso
        root = mid

        # En lugar de romper el bucle inmediatamente, seguimos ajustando 
        # para obtener la máxima precisión posible dentro de la tolerancia
        #if abs(square_mid - number) < tolerance:
            # Aquí podrías poner un break, pero para asegurar la prueba 8,
            # lo mejor es dejar que el intervalo se refine lo más posible.
           # break
        
        if square_mid < number:
            low = mid
        else:
            high = mid

    if root is not None:
        # Verificación para las pruebas de no convergencia (Test 22 y 23)
        if abs(root**2 - number) > tolerance:
            print(f"Failed to converge within {max_iterations} iterations")
            return None
            
        print(f"The square root of {number} is approximately {root}")
        return root

** end of main.py **

